<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · SpineInterface.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SpineInterface.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Constants-1">Constants</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/Spine-project/SpineInterface.jl/blob/master/docs/src/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><p>Documentation for <code>SpineInterface.jl</code>.</p><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Library-1">Library</a></li><ul><li><a href="#Contents-1">Contents</a></li><li><a href="#Index-1">Index</a></li><li><a href="#Types-1">Types</a></li><li><a href="#Functions-1">Functions</a></li><li><a href="#Constants-1">Constants</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#SpineInterface.anything"><code>SpineInterface.anything</code></a></li><li><a href="#SpineInterface.Anything"><code>SpineInterface.Anything</code></a></li><li><a href="#SpineInterface.Object"><code>SpineInterface.Object</code></a></li><li><a href="#SpineInterface.ObjectClass-Tuple{}"><code>SpineInterface.ObjectClass</code></a></li><li><a href="#SpineInterface.ObjectLike"><code>SpineInterface.ObjectLike</code></a></li><li><a href="#SpineInterface.Parameter-Tuple{}"><code>SpineInterface.Parameter</code></a></li><li><a href="#SpineInterface.RelationshipClass-Tuple{}"><code>SpineInterface.RelationshipClass</code></a></li><li><a href="#SpineInterface.TimeSlice-Tuple{DateTime,DateTime}"><code>SpineInterface.TimeSlice</code></a></li><li><a href="#SpineInterface.TimeSlice"><code>SpineInterface.TimeSlice</code></a></li><li><a href="#SpineInterface.before-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.before</code></a></li><li><a href="#SpineInterface.duration-Tuple{TimeSlice}"><code>SpineInterface.duration</code></a></li><li><a href="#SpineInterface.overlap_duration-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.overlap_duration</code></a></li><li><a href="#SpineInterface.overlaps-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.overlaps</code></a></li><li><a href="#SpineInterface.t_highest_resolution-Tuple{Any}"><code>SpineInterface.t_highest_resolution</code></a></li><li><a href="#SpineInterface.t_lowest_resolution-Tuple{Any}"><code>SpineInterface.t_lowest_resolution</code></a></li><li><a href="#SpineInterface.using_spinedb-Tuple{String}"><code>SpineInterface.using_spinedb</code></a></li></ul><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.ObjectLike" href="#SpineInterface.ObjectLike"><code>SpineInterface.ObjectLike</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ObjectLike</code></pre><p>Supertype for <a href="#SpineInterface.Object"><code>Object</code></a> and <a href="#SpineInterface.TimeSlice"><code>TimeSlice</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.Object" href="#SpineInterface.Object"><code>SpineInterface.Object</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Object</code></pre><p>A type for representing an object in a Spine db.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.TimeSlice" href="#SpineInterface.TimeSlice"><code>SpineInterface.TimeSlice</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TimeSlice</code></pre><p>A type for representing a slice of time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.Anything" href="#SpineInterface.Anything"><code>SpineInterface.Anything</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Anything</code></pre><p>A type with no fields that is the type of <a href="#SpineInterface.anything"><code>anything</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.using_spinedb-Tuple{String}" href="#SpineInterface.using_spinedb-Tuple{String}"><code>SpineInterface.using_spinedb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">using_spinedb(db_url::String; upgrade=false)</code></pre><p>Take the Spine database at the given RFC-1738 <code>url</code>, and export convenience <em>functors</em> named after each object class, relationship class, and parameter in it. These functors can be used to retrieve specific contents in the db.</p><p>If <code>upgrade</code> is <code>true</code>, then the database at <code>url</code> is upgraded to the latest revision.</p><p>See <a href="#SpineInterface.ObjectClass-Tuple{}"><code>ObjectClass()</code></a>, <a href="#SpineInterface.RelationshipClass-Tuple{}"><code>RelationshipClass()</code></a>, and <a href="#SpineInterface.Parameter-Tuple{}"><code>Parameter()</code></a> for details on how to call the convenience functors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.ObjectClass-Tuple{}" href="#SpineInterface.ObjectClass-Tuple{}"><code>SpineInterface.ObjectClass</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(&lt;oc&gt;::ObjectClass)(;&lt;keyword arguments&gt;)</code></pre><p>An <code>Array</code> of <a href="#SpineInterface.Object"><code>Object</code></a> instances corresponding to the objects in class <code>oc</code>.</p><p><strong>Arguments</strong></p><p>For each parameter associated to <code>oc</code> in the database there is a keyword argument named after it. The purpose is to filter the result by specific values of that parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SpineInterface;

julia&gt; url = &quot;sqlite:///&quot; * joinpath(dirname(pathof(SpineInterface)), &quot;..&quot;, &quot;examples/data/example.sqlite&quot;);

julia&gt; using_spinedb(url)

julia&gt; node()
5-element Array{Object,1}:
 Nimes
 Sthlm
 Leuven
 Espoo
 Dublin

julia&gt; commodity(state_of_matter=:gas)
1-element Array{Any,1}:
 wind
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.RelationshipClass-Tuple{}" href="#SpineInterface.RelationshipClass-Tuple{}"><code>SpineInterface.RelationshipClass</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(&lt;rc&gt;::RelationshipClass)(;&lt;keyword arguments&gt;)</code></pre><p>An <code>Array</code> of <a href="#SpineInterface.Object"><code>Object</code></a> tuples corresponding to the relationships of class <code>rc</code>.</p><p><strong>Arguments</strong></p><ul><li>For each object class in <code>rc</code> there is a keyword argument named after it. The purpose is to filter the result by an object or list of objects of that class, or to accept all objects of that class by specifying <code>anything</code> for this argument.</li><li><code>_compact::Bool=true</code>: whether or not filtered object classes should be removed from the resulting tuples.</li><li><code>_default=[]</code>: the default value to return in case no relationship passes the filter.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SpineInterface;

julia&gt; url = &quot;sqlite:///&quot; * joinpath(dirname(pathof(SpineInterface)), &quot;..&quot;, &quot;examples/data/example.sqlite&quot;);

julia&gt; using_spinedb(url)

julia&gt; node__commodity()
5-element Array{NamedTuple{(:node, :commodity),Tuple{Object,Object}},1}:
 (node = Dublin, commodity = wind)
 (node = Espoo, commodity = wind)
 (node = Leuven, commodity = wind)
 (node = Nimes, commodity = water)
 (node = Sthlm, commodity = water)

julia&gt; node__commodity(commodity=:water)
2-element Array{Object,1}:
 Nimes
 Sthlm

julia&gt; node__commodity(node=(:Dublin, :Espoo))
1-element Array{Object,1}:
 wind

julia&gt; node__commodity(node=anything)
2-element Array{Object,1}:
 wind
 water

julia&gt; node__commodity(commodity=:water, _compact=false)
2-element Array{NamedTuple{(:node, :commodity),Tuple{Object,Object}},1}:
 (node = Nimes, commodity = water)
 (node = Sthlm, commodity = water)

julia&gt; node__commodity(commodity=:gas, _default=:nogas)
:nogas
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.Parameter-Tuple{}" href="#SpineInterface.Parameter-Tuple{}"><code>SpineInterface.Parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(&lt;p&gt;::Parameter)(;&lt;keyword arguments&gt;)</code></pre><p>The values of parameter <code>p</code>. They are given as a <code>Dict</code> mapping object and relationship classes associated with <code>p</code>, to another <code>Dict</code> mapping corresponding objects or relationships to values.</p><p><strong>Arguments</strong></p><ul><li>For each object class associated with <code>p</code> there is a keyword argument named after it. The purpose is to retrieve the value of <code>p</code> for a specific object.</li><li>For each relationship class associated with <code>p</code>, there is a keyword argument named after each of the object classes involved in it. The purpose is to retrieve the value of <code>p</code> for a specific relationship.</li><li><code>i::Int64</code>: a specific index to retrieve in case of an array value (ignored otherwise).</li><li><code>t::TimeSlice</code>: a specific time-index to retrieve in case of a time-varying value (ignored otherwise).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SpineInterface;

julia&gt; url = &quot;sqlite:///&quot; * joinpath(dirname(pathof(SpineInterface)), &quot;..&quot;, &quot;examples/data/example.sqlite&quot;);

julia&gt; using_spinedb(url)

julia&gt; tax_net_flow(node=:Sthlm, commodity=:water)
4

julia&gt; demand(node=:Sthlm, i=1)
21
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.TimeSlice-Tuple{DateTime,DateTime}" href="#SpineInterface.TimeSlice-Tuple{DateTime,DateTime}"><code>SpineInterface.TimeSlice</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">TimeSlice(start::DateTime, end_::DateTime)</code></pre><p>Construct a <code>TimeSlice</code> with bounds given by <code>start</code> and <code>end_</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.duration-Tuple{TimeSlice}" href="#SpineInterface.duration-Tuple{TimeSlice}"><code>SpineInterface.duration</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">duration(t::TimeSlice)</code></pre><p>The duration of time slice <code>t</code> in minutes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.before-Tuple{TimeSlice,TimeSlice}" href="#SpineInterface.before-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.before</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">before(a::TimeSlice, b::TimeSlice)</code></pre><p>Determine whether the end point of <code>a</code> is exactly the start point of <code>b</code>.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>in(::TimeSlice, ::TimeSlice)</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.overlaps-Tuple{TimeSlice,TimeSlice}" href="#SpineInterface.overlaps-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.overlaps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">overlaps(a::TimeSlice, b::TimeSlice)</code></pre><p>Determine whether <code>a</code> and <code>b</code> overlap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.overlap_duration-Tuple{TimeSlice,TimeSlice}" href="#SpineInterface.overlap_duration-Tuple{TimeSlice,TimeSlice}"><code>SpineInterface.overlap_duration</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">overlap_duration(a::TimeSlice, b::TimeSlice)</code></pre><p>The number of minutes where <code>a</code> and <code>b</code> overlap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.t_lowest_resolution-Tuple{Any}" href="#SpineInterface.t_lowest_resolution-Tuple{Any}"><code>SpineInterface.t_lowest_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">t_lowest_resolution(iter)</code></pre><p>An <code>Array</code> with the <code>TimeSlice</code>s from the given iterable that are not contained in any other.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.t_highest_resolution-Tuple{Any}" href="#SpineInterface.t_highest_resolution-Tuple{Any}"><code>SpineInterface.t_highest_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">t_highest_resolution(iter)</code></pre><p>An <code>Array</code> with the <code>TimeSlice</code>s from the given iterable that do not contain any other.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>write_results(::String)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Constants-1" href="#Constants-1">Constants</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpineInterface.anything" href="#SpineInterface.anything"><code>SpineInterface.anything</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">anything</code></pre><p>The singleton instance of type <a href="#SpineInterface.Anything"><code>Anything</code></a>, used to specify <em>all-pass</em> filters in calls to <a href="#SpineInterface.RelationshipClass-Tuple{}"><code>RelationshipClass()</code></a>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
